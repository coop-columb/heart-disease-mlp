#!/usr/bin/env python3
"""
Generate environment-specific .env files for local development.
These files contain environment variables needed for each environment.
"""

import argparse
import os
from pathlib import Path

ENV_TEMPLATES = {
    "dev": """# Development Environment Variables
# This file was auto-generated by generate_env_file.py
# It contains environment variables for the development environment

# Authentication
JWT_SECRET_KEY=dev_secret_key_change_me_in_production

# API Keys (for testing)
API_KEY_DEVELOPMENT=dev_api_key

# Backup Settings
BACKUP_FREQUENCY=daily
KEEP_BACKUPS=5
CLOUD_BACKUP=false

# Logging
LOG_LEVEL=debug

# Database (if applicable)
DB_HOST=localhost
DB_PORT=5432
DB_NAME=heartdisease_dev
DB_USER=dev_user
DB_PASSWORD=dev_password
""",
    "staging": """# Staging Environment Variables
# This file was auto-generated by generate_env_file.py
# It contains environment variables for the staging environment

# Authentication
JWT_SECRET_KEY=staging_secret_key_change_me_in_production

# API Keys (for testing)
API_KEY_STAGING=staging_api_key
API_KEY_TESTING=test_api_key

# Backup Settings
BACKUP_FREQUENCY=daily
KEEP_BACKUPS=10
CLOUD_BACKUP=true
CLOUD_PROVIDER=s3
AWS_ACCESS_KEY_ID=your_staging_aws_access_key
AWS_SECRET_ACCESS_KEY=your_staging_aws_secret_key
AWS_BUCKET_NAME=your-staging-bucket

# Logging
LOG_LEVEL=info

# Database (if applicable)
DB_HOST=staging-db.example.com
DB_PORT=5432
DB_NAME=heartdisease_staging
DB_USER=staging_user
DB_PASSWORD=staging_password
""",
    "prod": """# Production Environment Variables
# This file was auto-generated by generate_env_file.py
# It contains environment variables for the production environment

# Authentication
JWT_SECRET_KEY=change_me_to_a_secure_random_key_in_production

# API Keys (production - you should change these)
API_KEY_PRODUCTION=change_me_to_a_secure_api_key
API_KEY_ADMIN=change_me_to_a_secure_admin_key

# Backup Settings
BACKUP_FREQUENCY=hourly
KEEP_BACKUPS=24
CLOUD_BACKUP=true
CLOUD_PROVIDER=s3
AWS_ACCESS_KEY_ID=your_prod_aws_access_key
AWS_SECRET_ACCESS_KEY=your_prod_aws_secret_key
AWS_BUCKET_NAME=your-production-bucket

# Logging
LOG_LEVEL=warning

# Database (if applicable)
DB_HOST=db.example.com
DB_PORT=5432
DB_NAME=heartdisease_prod
DB_USER=prod_user
DB_PASSWORD=prod_secure_password
""",
}


def generate_env_file(env: str, output_dir: str = None) -> str:
    """
    Generate a .env file for the specified environment.

    Args:
        env: Environment name (dev, staging, prod)
        output_dir: Directory to save the .env file in

    Returns:
        Path to the generated .env file
    """
    if env not in ENV_TEMPLATES:
        raise ValueError(f"Unknown environment: {env}")

    if output_dir is None:
        output_dir = str(Path(__file__).parent.parent)

    env_file_path = os.path.join(output_dir, f".env.{env}")

    with open(env_file_path, "w") as f:
        f.write(ENV_TEMPLATES[env])

    print(f"Generated {env_file_path}")
    return env_file_path


def main():
    parser = argparse.ArgumentParser(description="Generate environment-specific .env files")
    parser.add_argument(
        "environment",
        choices=["dev", "staging", "prod", "all"],
        help="Environment to generate .env file for",
    )
    parser.add_argument("--output", help="Directory to save the .env file in")

    args = parser.parse_args()

    if args.environment == "all":
        for env in ENV_TEMPLATES.keys():
            generate_env_file(env, args.output)
    else:
        generate_env_file(args.environment, args.output)


if __name__ == "__main__":
    main()
